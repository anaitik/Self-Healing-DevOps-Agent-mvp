/**
 * Create GitHub branch, apply suggested patch, open Pull Request.
 * POST /api/remediate â€“ body: { incidentId, remediationPlan }
 */
import { Router } from 'express';

const router = Router();
const GITHUB_TOKEN = process.env.GITHUB_TOKEN || '';
const GITHUB_REPO = process.env.GITHUB_REPO || '';

const API = 'https://api.github.com';

function gh(path, options = {}) {
  const url = path.startsWith('http') ? path : `${API}/repos/${GITHUB_REPO}${path}`;
  return fetch(url, {
    ...options,
    headers: {
      Accept: 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28',
      Authorization: GITHUB_TOKEN ? `Bearer ${GITHUB_TOKEN}` : '',
      ...options.headers,
    },
  });
}

/** POST /api/remediate */
router.post('/remediate', async (req, res) => {
  if (!GITHUB_TOKEN || !GITHUB_REPO) {
    return res.status(503).json({
      error: 'GITHUB_TOKEN and GITHUB_REPO must be set to create PRs',
      pr_url: null,
    });
  }
  const { incidentId, remediationPlan } = req.body || {};
  if (!incidentId || !remediationPlan) {
    return res.status(400).json({ error: 'incidentId and remediationPlan required', pr_url: null });
  }

  const branch = (remediationPlan.suggested_branch_name || `fix/${incidentId.toLowerCase().replace(/[^a-z0-9-]/g, '-')}`).slice(0, 200);
  const commitMessage = remediationPlan.suggested_commit_message || `fix: resolve ${incidentId}`;
  const patch = remediationPlan.suggested_code_patch || '';
  const targetFile = remediationPlan.target_file || (remediationPlan.affected_components && remediationPlan.affected_components[0]) || null;

  try {
    const repoRes = await gh('');
    if (!repoRes.ok) {
      const err = await repoRes.json().catch(() => ({}));
      return res.status(repoRes.status).json({
        error: err.message || 'Failed to access GitHub repo',
        pr_url: null,
      });
    }
    const repo = await repoRes.json();
    const defaultBranch = repo.default_branch || 'main';

    const refRes = await gh(`/git/ref/heads/${defaultBranch}`);
    if (!refRes.ok) {
      return res.status(refRes.status).json({ error: 'Failed to get default branch ref', pr_url: null });
    }
    const refData = await refRes.json();
    const baseSha = refData.object.sha;

    const createRefRes = await gh('/git/refs', {
      method: 'POST',
      body: JSON.stringify({
        ref: `refs/heads/${branch}`,
        sha: baseSha,
      }),
    });
    if (!createRefRes.ok) {
      const errData = await createRefRes.json().catch(() => ({}));
      if (createRefRes.status === 422 && errData.message?.includes('already exists')) {
        // Branch exists: use it (optional: could delete and recreate)
        // For simplicity we'll return error and ask user to use a different branch name
        return res.status(409).json({
          error: `Branch ${branch} already exists. Reject and re-analyze to get a new branch name.`,
          pr_url: null,
        });
      }
      return res.status(createRefRes.status).json({
        error: errData.message || 'Failed to create branch',
        pr_url: null,
      });
    }

    let filePath = targetFile && targetFile.includes('.') ? targetFile : null;
    if (!filePath) {
      filePath = `patches/${branch.replace(/\//g, '-')}.patch`;
    }

    let currentContent = '';
    let fileSha = null;
    const getContentRes = await gh(`/contents/${encodeURIComponent(filePath)}?ref=${branch}`);
    if (getContentRes.ok) {
      const contentData = await getContentRes.json();
      currentContent = Buffer.from(contentData.content, 'base64').toString('utf8');
      fileSha = contentData.sha;
    }

    const newContent = patch.trim()
      ? (currentContent ? currentContent + '\n\n--- Suggested patch ---\n' + patch : patch)
      : currentContent || '(No patch content provided)';

    const updateRes = await gh(`/contents/${encodeURIComponent(filePath)}`, {
      method: 'PUT',
      body: JSON.stringify({
        message: commitMessage,
        content: Buffer.from(newContent, 'utf8').toString('base64'),
        branch,
        sha: fileSha || undefined,
      }),
    });
    if (!updateRes.ok) {
      const errData = await updateRes.json().catch(() => ({}));
      return res.status(updateRes.status).json({
        error: errData.message || 'Failed to create/update file',
        pr_url: null,
      });
    }

    const prRes = await gh('/pulls', {
      method: 'POST',
      body: JSON.stringify({
        title: commitMessage.slice(0, 255),
        head: branch,
        base: defaultBranch,
        body: `## HealFlow remediation for ${incidentId}\n\n**Root cause:** ${remediationPlan.root_cause_category}\n\n${remediationPlan.root_cause_summary || ''}\n\n---\n*Auto-generated by HealFlow*`,
      }),
    });
    if (!prRes.ok) {
      const errData = await prRes.json().catch(() => ({}));
      return res.status(prRes.status).json({
        error: errData.message || 'Failed to create PR',
        pr_url: null,
      });
    }
    const pr = await prRes.json();
    return res.json({ ok: true, pr_url: pr.html_url, pr_number: pr.number });
  } catch (e) {
    return res.status(500).json({
      error: e.message || 'Remediation failed',
      pr_url: null,
    });
  }
});

export default router;
